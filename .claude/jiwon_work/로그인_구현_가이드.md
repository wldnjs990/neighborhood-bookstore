# JWT 로그인 구현 가이드

## 목차
1. [전체 구조 개요](#전체-구조-개요)
2. [백엔드 (Django) 설정](#백엔드-django-설정)
3. [프론트엔드 (Vue.js) 구현](#프론트엔드-vuejs-구현)
4. [camelCase ↔ snake_case 자동 변환](#camelcase--snake_case-자동-변환)
5. [로그인 플로우](#로그인-플로우)
6. [로그아웃 플로우](#로그아웃-플로우)
7. [토큰 갱신 (Auto Refresh)](#토큰-갱신-auto-refresh)
8. [자주 발생하는 에러와 해결법](#자주-발생하는-에러와-해결법)

---

## 전체 구조 개요

### 인증 방식: JWT (JSON Web Token)

```
┌─────────────┐           ┌─────────────┐
│  Frontend   │           │   Backend   │
│  (Vue.js)   │  ◄─────►  │  (Django)   │
└─────────────┘           └─────────────┘
      │                          │
      ├─ Access Token            ├─ JWT 발급
      ├─ Refresh Token           ├─ Token 검증
      └─ localStorage            └─ Blacklist 관리
```

**주요 개념**:
- **Access Token**: 짧은 수명(1시간), API 요청 시 사용
- **Refresh Token**: 긴 수명(7일), Access Token 재발급용
- **Token Blacklist**: 로그아웃한 토큰을 무효화

---

## 백엔드 (Django) 설정

### 1. 필요한 패키지 설치

```bash
pip install djangorestframework
pip install djangorestframework-simplejwt
pip install djangorestframework-camel-case
pip install django-cors-headers
```

### 2. settings.py 설정

```python
# settings.py

INSTALLED_APPS = [
    # ...
    'rest_framework',
    'rest_framework_simplejwt',
    'rest_framework_simplejwt.token_blacklist',  # 로그아웃용
    'corsheaders',  # CORS 설정
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # 최상단에 위치
    # ... 다른 미들웨어
]

# JWT 설정
from datetime import timedelta

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),      # Access Token 수명
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),      # Refresh Token 수명
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
    'AUTH_HEADER_TYPES': ('Bearer',),
}

# Django REST Framework 설정
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    # camelCase 자동 변환 (중요!)
    'DEFAULT_RENDERER_CLASSES': [
        'djangorestframework_camel_case.render.CamelCaseJSONRenderer',
        'djangorestframework_camel_case.render.CamelCaseBrowsableAPIRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'djangorestframework_camel_case.parser.CamelCaseJSONParser',
        'djangorestframework_camel_case.parser.CamelCaseFormParser',
        'djangorestframework_camel_case.parser.CamelCaseMultiPartParser',
    ],
}

# CORS 설정 (프론트엔드와 통신 허용)
CORS_ALLOWED_ORIGINS = [
    'http://localhost:5173',  # Vite 개발 서버
    'http://127.0.0.1:5173',
]

CORS_ALLOW_CREDENTIALS = True  # 쿠키/인증 정보 허용
```

### 3. views.py - 로그인/로그아웃 API

```python
# accounts/views.py

from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import authenticate

@api_view(['POST'])
@permission_classes([AllowAny])
def login(request):
    """로그인 - Access Token과 Refresh Token 발급"""
    username = request.data.get('username')
    password = request.data.get('password')

    # 사용자 인증
    user = authenticate(username=username, password=password)

    if user is not None:
        # JWT 토큰 생성
        refresh = RefreshToken.for_user(user)

        return Response({
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
            },
            'access': str(refresh.access_token),
            'refresh': str(refresh),
        }, status=status.HTTP_200_OK)

    return Response(
        {'error': '아이디 또는 비밀번호가 올바르지 않습니다.'},
        status=status.HTTP_401_UNAUTHORIZED
    )

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout(request):
    """로그아웃 - Refresh Token을 블랙리스트에 추가"""
    try:
        refresh_token = request.data.get('refresh')

        if not refresh_token:
            return Response(
                {'error': 'Refresh token이 필요합니다.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 토큰 블랙리스트 등록 (재사용 불가)
        token = RefreshToken(refresh_token)
        token.blacklist()

        return Response(
            {'message': '로그아웃되었습니다.'},
            status=status.HTTP_205_RESET_CONTENT
        )
    except Exception as e:
        return Response(
            {'error': str(e)},
            status=status.HTTP_400_BAD_REQUEST
        )
```

---

## 프론트엔드 (Vue.js) 구현

### 폴더 구조

```
frontend/src/
├── api/
│   ├── client.js        # Axios 인스턴스 + 인터셉터
│   └── accounts.js      # 계정 관련 API 함수
├── stores/
│   └── loginStore.js    # 로그인 상태 관리 (Pinia)
└── views/
    ├── LoginView.vue    # 로그인 페이지
    └── SignupView.vue   # 회원가입 페이지
```

### 1. Axios Client 설정

**파일**: `frontend/src/api/client.js`

```javascript
import axios from 'axios'
import { useLoginStore } from '@/stores/loginStore'
import { refreshToken } from '@/api/accounts'

// Axios 인스턴스 생성
const client = axios.create({
  baseURL: 'http://localhost:8000',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
})

// 요청 인터셉터: 모든 요청에 Access Token 자동 추가
client.interceptors.request.use(
  (config) => {
    const loginStore = useLoginStore()

    // Authorization 헤더에 Bearer 토큰 추가
    if (loginStore.token) {
      config.headers.Authorization = `Bearer ${loginStore.token}`
    }

    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 응답 인터셉터: 401 에러 시 자동으로 토큰 갱신
client.interceptors.response.use(
  (response) => response,  // 성공 시 그대로 반환
  async (error) => {
    // 네트워크 에러 처리
    if (!error.response) {
      if (error.code === 'ECONNABORTED') {
        console.error('요청 시간이 초과되었습니다')
      } else if (error.code === 'ERR_NETWORK') {
        console.error('네트워크 연결을 확인해주세요')
      }
      return Promise.reject(error)
    }

    const { config: originalRequest, response } = error
    const { status } = response

    // 401 Unauthorized: 토큰 만료
    if (status === 401 && !originalRequest._retry) {
      originalRequest._retry = true  // 무한 루프 방지

      const loginStore = useLoginStore()

      // Refresh Token으로 새 Access Token 발급
      if (loginStore.refreshToken && !originalRequest.url.includes('/token/refresh/')) {
        try {
          const data = await refreshToken(loginStore.refreshToken)

          // 새 Access Token 저장
          loginStore.updateAccessToken(data.access)

          // 원래 요청에 새 토큰 적용 후 재시도
          originalRequest.headers.Authorization = `Bearer ${data.access}`
          return client(originalRequest)
        } catch (refreshError) {
          // Refresh Token도 만료 → 로그인 페이지로 이동
          loginStore.clearTokens()
          window.location.href = '/login'
          return Promise.reject(refreshError)
        }
      } else {
        // Refresh Token 없음 → 로그인 페이지로 이동
        loginStore.clearTokens()
        window.location.href = '/login'
      }
    }

    return Promise.reject(error)
  }
)

export default client
```

**핵심 로직**:
1. **요청 인터셉터**: 모든 API 요청에 자동으로 `Authorization: Bearer <token>` 헤더 추가
2. **응답 인터셉터**: 401 에러 발생 시 자동으로 Refresh Token으로 새 Access Token 발급 후 재요청
3. **무한 루프 방지**: `_retry` 플래그로 한 번만 재시도

---

### 2. API 함수 정의

**파일**: `frontend/src/api/accounts.js`

```javascript
import client from '@/api/client'
import { useLoginStore } from '@/stores/loginStore'

// 로그인
export const login = async (credentials) => {
  const response = await client.post('/api/accounts/login/', credentials)
  return response.data
}

// 회원가입
export const signup = async (userData) => {
  const response = await client.post('/api/accounts/signup/', userData)
  return response.data
}

// 토큰 갱신 (인터셉터에서 사용)
export const refreshToken = async (refreshToken) => {
  const response = await client.post('/api/accounts/token/refresh/', {
    refresh: refreshToken,
  })
  return response.data
}

// 로그아웃
export const logout = async () => {
  const loginStore = useLoginStore()

  const response = await client.post('/api/accounts/logout/', {
    refresh: loginStore.refreshToken,  // Refresh Token 전송
  })
  return response.data
}
```

**왜 API 레이어를 분리하나요?**
- **관심사 분리**: API 호출 로직을 한 곳에 모아 관리
- **재사용성**: 여러 컴포넌트에서 동일한 API 함수 사용
- **유지보수**: API URL이 변경되어도 한 곳만 수정

---

### 3. Pinia Store (상태 관리)

**파일**: `frontend/src/stores/loginStore.js`

```javascript
import { ref } from 'vue'
import { defineStore } from 'pinia'

export const useLoginStore = defineStore('login', () => {
  // 상태 (State)
  const token = ref(localStorage.getItem('access_token') || null)
  const refreshToken = ref(localStorage.getItem('refresh_token') || null)
  const user = ref(JSON.parse(localStorage.getItem('user') || 'null'))

  // 액션 (Actions)

  // 로그인 시: 두 토큰 모두 저장
  const setTokens = (accessToken, newRefreshToken) => {
    token.value = accessToken
    refreshToken.value = newRefreshToken

    localStorage.setItem('access_token', accessToken)
    localStorage.setItem('refresh_token', newRefreshToken)
  }

  // 토큰 갱신 시: Access Token만 업데이트
  const updateAccessToken = (accessToken) => {
    token.value = accessToken
    localStorage.setItem('access_token', accessToken)
  }

  // 로그아웃 시: 모든 정보 제거
  const clearTokens = () => {
    token.value = null
    refreshToken.value = null
    user.value = null

    localStorage.removeItem('access_token')
    localStorage.removeItem('refresh_token')
    localStorage.removeItem('user')
  }

  return {
    token,
    refreshToken,
    user,
    setTokens,
    updateAccessToken,
    clearTokens,
  }
})
```

**왜 localStorage를 사용하나요?**
- 브라우저를 닫아도 로그인 상태 유지
- Pinia store는 새로고침 시 초기화되므로 localStorage에 백업

---

### 4. 로그인 페이지

**파일**: `frontend/src/views/LoginView.vue`

```vue
<template>
  <section class="flex min-h-screen items-center justify-center">
    <div class="w-full max-w-md space-y-8 rounded-lg bg-white p-8 shadow-md">
      <div class="text-center">
        <h1 class="text-3xl font-bold">로그인</h1>
      </div>

      <form @submit.prevent="handleLogin" class="mt-8 space-y-6">
        <div class="space-y-4">
          <!-- 아이디 입력 -->
          <div>
            <label for="username" class="block text-sm font-medium text-gray-700">
              아이디
            </label>
            <input
              id="username"
              v-model="username"
              type="text"
              required
              class="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
              placeholder="아이디를 입력하세요"
            />
          </div>

          <!-- 비밀번호 입력 -->
          <div>
            <label for="password" class="block text-sm font-medium text-gray-700">
              비밀번호
            </label>
            <input
              id="password"
              v-model="password"
              type="password"
              required
              class="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
              placeholder="비밀번호를 입력하세요"
            />
          </div>
        </div>

        <!-- 에러 메시지 -->
        <div v-if="errorMessage" class="text-sm text-red-600">
          {{ errorMessage }}
        </div>

        <!-- 로그인 버튼 -->
        <button
          type="submit"
          :disabled="isLoading"
          class="w-full rounded-md bg-blue-600 px-4 py-2 text-white hover:bg-blue-700 disabled:bg-gray-400"
        >
          {{ isLoading ? '로그인 중...' : '로그인' }}
        </button>
      </form>
    </div>
  </section>
</template>

<script setup>
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useLoginStore } from '@/stores/loginStore'
import { login } from '@/api/accounts'

const router = useRouter()
const loginStore = useLoginStore()

const username = ref('')
const password = ref('')
const isLoading = ref(false)
const errorMessage = ref('')

const handleLogin = async () => {
  errorMessage.value = ''
  isLoading.value = true

  try {
    // 1. API 호출
    const data = await login({
      username: username.value,
      password: password.value,
    })

    // 2. Store에 토큰 저장
    loginStore.setTokens(data.access, data.refresh)

    // 3. 사용자 정보 저장
    if (data.user) {
      loginStore.user = data.user
      localStorage.setItem('user', JSON.stringify(data.user))
    }

    // 4. 홈 페이지로 이동
    router.push('/')
  } catch (error) {
    console.error('로그인 실패:', error)
    errorMessage.value = '아이디 또는 비밀번호가 올바르지 않습니다.'
  } finally {
    isLoading.value = false
  }
}
</script>
```

---

### 5. 로그아웃 구현

**파일**: `frontend/src/layout/components/Navbar.vue`

```vue
<template>
  <div class="navbar">
    <ul>
      <li>
        <a @click="handleLogout" v-if="loginStore.token">로그아웃</a>
        <RouterLink to="/login" v-else>로그인</RouterLink>
      </li>
    </ul>
  </div>
</template>

<script setup>
import { useLoginStore } from '@/stores/loginStore'
import { logout } from '@/api/accounts'

const loginStore = useLoginStore()

const handleLogout = async () => {
  try {
    // 1. 먼저 서버에 로그아웃 요청 (토큰 블랙리스트 등록)
    await logout()

    // 2. 성공하면 로컬 토큰 제거
    loginStore.clearTokens()
  } catch (error) {
    // 에러가 나도 로컬 토큰은 제거 (이미 만료되었을 수 있음)
    console.error('로그아웃 실패:', error)
    loginStore.clearTokens()
  }
}
</script>
```

**중요**: `await`를 사용해서 서버 요청이 완료된 후에 토큰을 제거해야 합니다!

---

## camelCase ↔ snake_case 자동 변환

### 문제 상황

```javascript
// 프론트엔드 (JavaScript - camelCase)
{
  passwordConfirm: "1234",
  firstName: "홍길동"
}

// 백엔드 (Python - snake_case)
{
  password_confirm: "1234",
  first_name: "홍길동"
}
```

- JavaScript는 `camelCase` 사용
- Python/Django는 `snake_case` 사용
- 이 차이 때문에 400 Bad Request 에러 발생!

### 해결 방법: djangorestframework-camel-case

#### 1. 설치

```bash
pip install djangorestframework-camel-case
```

#### 2. settings.py 설정

```python
REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        'djangorestframework_camel_case.render.CamelCaseJSONRenderer',
        'djangorestframework_camel_case.render.CamelCaseBrowsableAPIRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'djangorestframework_camel_case.parser.CamelCaseJSONParser',
        'djangorestframework_camel_case.parser.CamelCaseFormParser',
        'djangorestframework_camel_case.parser.CamelCaseMultiPartParser',
    ],
}
```

#### 3. 동작 방식

**요청 (프론트 → 백)**:
```javascript
// 프론트엔드가 보냄
{
  passwordConfirm: "1234"
}

// Django가 받음 (자동 변환)
{
  password_confirm: "1234"
}
```

**응답 (백 → 프론트)**:
```python
# Django가 보냄
{
  first_name: "홍길동",
  access_token: "eyJ0..."
}

# 프론트엔드가 받음 (자동 변환)
{
  firstName: "홍길동",
  accessToken: "eyJ0..."
}
```

### 다른 프레임워크는 어떻게 처리하나요?

| 프레임워크 | 변환 방법 |
|----------|----------|
| **Spring (Java)** | `@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)` |
| **Express (Node.js)** | `humps` 라이브러리 또는 커스텀 미들웨어 |
| **NestJS (TypeScript)** | `class-transformer` + `@Expose()` 데코레이터 |
| **FastAPI (Python)** | Pydantic의 `alias` 사용 |
| **Rails (Ruby)** | `active_model_serializers` gem |

**핵심**: 프론트엔드가 camelCase를 사용하면, 백엔드가 자동으로 변환해주는 것이 표준!

---

## 로그인 플로우

```
1. 사용자가 아이디/비밀번호 입력
   │
   ▼
2. LoginView.vue → handleLogin() 실행
   │
   ▼
3. accounts.js → login() API 호출
   │
   ▼
4. Django → authenticate() 검증
   │
   ├─ 성공 → Access Token + Refresh Token 발급
   │          {
   │            "access": "eyJ0eXAi...",
   │            "refresh": "eyJ0eXAi...",
   │            "user": { ... }
   │          }
   │
   └─ 실패 → 401 Unauthorized
   │
   ▼
5. loginStore.setTokens() 호출
   ├─ token.value = access
   ├─ refreshToken.value = refresh
   ├─ localStorage.setItem('access_token', ...)
   └─ localStorage.setItem('refresh_token', ...)
   │
   ▼
6. router.push('/') → 홈으로 이동
```

---

## 로그아웃 플로우

```
1. 사용자가 로그아웃 버튼 클릭
   │
   ▼
2. Navbar.vue → handleLogout() 실행
   │
   ▼
3. accounts.js → logout() API 호출
   ├─ 요청 Body: { refresh: "eyJ0eXAi..." }
   └─ 헤더: Authorization: Bearer <access_token>
   │
   ▼
4. Django → RefreshToken.blacklist() 실행
   └─ 해당 Refresh Token을 블랙리스트에 등록
   │
   ▼
5. loginStore.clearTokens() 호출
   ├─ token.value = null
   ├─ refreshToken.value = null
   ├─ user.value = null
   ├─ localStorage.removeItem('access_token')
   ├─ localStorage.removeItem('refresh_token')
   └─ localStorage.removeItem('user')
   │
   ▼
6. 로그인 페이지로 이동
```

**중요**: `await logout()`을 먼저 실행한 후 `clearTokens()`를 호출해야 합니다!

---

## 토큰 갱신 (Auto Refresh)

### 왜 Access Token 수명이 짧나요?

- **보안**: Access Token이 탈취되어도 1시간 후 자동 만료
- **편의성**: Refresh Token으로 자동 갱신하여 사용자 경험 유지

### 자동 갱신 플로우

```
1. 사용자가 API 요청 (예: 프로필 조회)
   │
   ▼
2. client.js 요청 인터셉터
   └─ Authorization: Bearer <access_token> 추가
   │
   ▼
3. Django에서 401 Unauthorized 반환 (토큰 만료)
   │
   ▼
4. client.js 응답 인터셉터에서 401 감지
   │
   ▼
5. refreshToken() 호출
   ├─ POST /api/accounts/token/refresh/
   └─ Body: { refresh: "eyJ0eXAi..." }
   │
   ▼
6. Django → 새 Access Token 발급
   └─ { "access": "새로운토큰..." }
   │
   ▼
7. loginStore.updateAccessToken() 호출
   └─ localStorage에 새 Access Token 저장
   │
   ▼
8. 원래 요청을 새 토큰으로 재시도
   └─ 사용자는 아무것도 모르고 자연스럽게 계속 사용
```

---

## 자주 발생하는 에러와 해결법

### 1. 400 Bad Request: "Refresh token이 필요합니다"

**원인**:
- 프론트엔드에서 Refresh Token을 전송하지 않았거나
- localStorage에 Refresh Token이 없음

**해결**:
```javascript
// ✅ 올바른 방법
const handleLogout = async () => {
  await logout()  // 먼저 서버에 요청
  loginStore.clearTokens()  // 그 다음 로컬 제거
}

// ❌ 잘못된 방법
const handleLogout = () => {
  logout()  // await 없이 실행
  loginStore.clearTokens()  // 바로 토큰 제거 → API 요청에 토큰이 없음!
}
```

### 2. CORS 에러

**원인**:
- Django에서 프론트엔드 도메인을 허용하지 않음

**해결**:
```python
# settings.py
CORS_ALLOWED_ORIGINS = [
    'http://localhost:5173',  # Vite 개발 서버
    'http://127.0.0.1:5173',
]

CORS_ALLOW_CREDENTIALS = True
```

### 3. 401 Unauthorized가 계속 발생

**원인**:
- Access Token이 localStorage에 저장되지 않음
- 로그인 API가 토큰을 반환하지 않음

**해결**:
```javascript
// 로그인 후 콘솔에서 확인
console.log(localStorage.getItem('access_token'))  // null이면 저장 안 됨
console.log(loginStore.token)  // null이면 store 업데이트 안 됨
```

### 4. 무한 리프레시 루프

**원인**:
- `_retry` 플래그가 없어서 토큰 갱신이 계속 반복됨

**해결**:
```javascript
// client.js 응답 인터셉터
if (status === 401 && !originalRequest._retry) {
  originalRequest._retry = true  // 이 줄이 없으면 무한 루프!
  // ...
}
```

### 5. 로그아웃 후에도 토큰이 남아있음

**원인**:
- `clearTokens()`를 호출하지 않았거나
- localStorage.removeItem()을 빠뜨림

**해결**:
```javascript
const clearTokens = () => {
  token.value = null
  refreshToken.value = null
  user.value = null

  localStorage.removeItem('access_token')
  localStorage.removeItem('refresh_token')
  localStorage.removeItem('user')
}
```

---

## 체크리스트

### 백엔드 (Django)

- [ ] `djangorestframework-simplejwt` 설치
- [ ] `djangorestframework-camel-case` 설치
- [ ] `django-cors-headers` 설치
- [ ] settings.py에 INSTALLED_APPS 추가
- [ ] SIMPLE_JWT 설정 (토큰 수명)
- [ ] REST_FRAMEWORK에 camelCase 파서/렌더러 추가
- [ ] CORS_ALLOWED_ORIGINS 설정
- [ ] login, logout, signup view 구현

### 프론트엔드 (Vue.js)

- [ ] axios 설치
- [ ] client.js 생성 (인터셉터 설정)
- [ ] accounts.js 생성 (API 함수)
- [ ] loginStore.js 생성 (Pinia store)
- [ ] LoginView.vue 구현
- [ ] 로그아웃 버튼에 `async/await` 사용
- [ ] localStorage에 토큰 저장 확인
- [ ] 401 에러 시 자동 토큰 갱신 테스트

---

## 추가 참고 자료

- [Django REST Framework JWT 공식 문서](https://django-rest-framework-simplejwt.readthedocs.io/)
- [djangorestframework-camel-case GitHub](https://github.com/vbabiy/djangorestframework-camel-case)
- [Axios 인터셉터 가이드](https://axios-http.com/docs/interceptors)
- [Pinia 공식 문서](https://pinia.vuejs.org/)

---

**작성일**: 2024년
**작성자**: 지원님 프로젝트 문서화
